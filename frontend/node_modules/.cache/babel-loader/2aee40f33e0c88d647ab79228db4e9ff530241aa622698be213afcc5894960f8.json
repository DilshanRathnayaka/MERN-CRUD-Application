{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useEffect, useRef } from 'react';\nimport useMutationObserver from './useMutationObserver';\nimport { getStyleStr, getPixelRatio, rotateWatermark } from './utils';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nconst BaseSize = 2;\nconst FontGap = 3;\nconst Watermark = props => {\n  var _a, _b;\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    gap = [100, 100],\n    offset,\n    children\n  } = props;\n  const {\n    color = 'rgba(0,0,0,.15)',\n    fontSize = 16,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif'\n  } = font;\n  const [gapX, gapY] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  const getMarkStyle = () => {\n    const markStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      markStyle.left = `${positionLeft}px`;\n      markStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      markStyle.top = `${positionTop}px`;\n      markStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n    markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return markStyle;\n  };\n  const containerRef = useRef(null);\n  const watermarkRef = useRef();\n  const {\n    createObserver,\n    destroyObserver,\n    reRendering\n  } = useMutationObserver();\n  const destroyWatermark = () => {\n    if (watermarkRef.current) {\n      watermarkRef.current.remove();\n      watermarkRef.current = undefined;\n    }\n  };\n  const appendWatermark = (base64Url, markWidth) => {\n    var _a;\n    if (containerRef.current && watermarkRef.current) {\n      destroyObserver();\n      watermarkRef.current.setAttribute('style', getStyleStr(Object.assign(Object.assign({}, getMarkStyle()), {\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${(gapX + markWidth) * BaseSize}px`\n      })));\n      (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.current);\n      createObserver(containerRef.current, mutations => {\n        mutations.forEach(mutation => {\n          if (reRendering(mutation, watermarkRef.current)) {\n            destroyWatermark();\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderWatermark();\n          }\n        });\n      });\n    }\n  };\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const widths = contents.map(item => ctx.measureText(item).width);\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(widths)));\n      defaultHeight = Number(fontSize) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n    const ratio = getPixelRatio();\n    const mergedFontSize = Number(fontSize) * ratio;\n    ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${drawHeight}px ${fontFamily}`;\n    ctx.fillStyle = color;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    ctx.translate(drawWidth / 2, 0);\n    const contents = Array.isArray(content) ? content : [content];\n    contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n      ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n    });\n  };\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      if (!watermarkRef.current) {\n        watermarkRef.current = document.createElement('div');\n      }\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const canvasWidth = (gapX + markWidth) * ratio;\n      const canvasHeight = (gapY + markHeight) * ratio;\n      canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n      canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n      const drawX = gapX * ratio / 2;\n      const drawY = gapY * ratio / 2;\n      const drawWidth = markWidth * ratio;\n      const drawHeight = markHeight * ratio;\n      const rotateX = (drawWidth + gapX * ratio) / 2;\n      const rotateY = (drawHeight + gapY * ratio) / 2;\n      /** Alternate drawing parameters */\n      const alternateDrawX = drawX + canvasWidth;\n      const alternateDrawY = drawY + canvasHeight;\n      const alternateRotateX = rotateX + canvasWidth;\n      const alternateRotateY = rotateY + canvasHeight;\n      ctx.save();\n      rotateWatermark(ctx, rotateX, rotateY, rotate);\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n          /** Draw interleaved pictures after rotation */\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        };\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n        /** Fill the interleaved text after rotation */\n        ctx.restore();\n        rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n        fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n        appendWatermark(canvas.toDataURL(), markWidth);\n      }\n    }\n  };\n  useEffect(renderWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, gapX, gapY, offsetLeft, offsetTop]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    className: className,\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, children);\n};\nexport default Watermark;","map":{"version":3,"names":["_toConsumableArray","React","useEffect","useRef","useMutationObserver","getStyleStr","getPixelRatio","rotateWatermark","BaseSize","FontGap","Watermark","props","_a","_b","zIndex","rotate","width","height","image","content","font","style","className","gap","offset","children","color","fontSize","fontWeight","fontStyle","fontFamily","gapX","gapY","gapXCenter","gapYCenter","offsetLeft","offsetTop","getMarkStyle","markStyle","position","left","top","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","containerRef","watermarkRef","createObserver","destroyObserver","reRendering","destroyWatermark","current","remove","undefined","appendWatermark","base64Url","markWidth","setAttribute","Object","assign","backgroundImage","backgroundSize","append","mutations","forEach","mutation","renderWatermark","getMarkSize","ctx","defaultWidth","defaultHeight","measureText","Number","contents","Array","isArray","widths","map","item","Math","ceil","max","apply","length","fillTexts","drawX","drawY","drawWidth","drawHeight","ratio","mergedFontSize","fillStyle","textAlign","textBaseline","translate","index","fillText","canvas","document","createElement","getContext","markHeight","canvasWidth","canvasHeight","rotateX","rotateY","alternateDrawX","alternateDrawY","alternateRotateX","alternateRotateY","save","img","Image","onload","drawImage","restore","toDataURL","crossOrigin","referrerPolicy","src","ref"],"sources":["C:/Users/nimes/OneDrive/Desktop/Project/Imageupload/frontend/node_modules/antd/es/watermark/index.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useEffect, useRef } from 'react';\nimport useMutationObserver from './useMutationObserver';\nimport { getStyleStr, getPixelRatio, rotateWatermark } from './utils';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nconst BaseSize = 2;\nconst FontGap = 3;\nconst Watermark = props => {\n  var _a, _b;\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    gap = [100, 100],\n    offset,\n    children\n  } = props;\n  const {\n    color = 'rgba(0,0,0,.15)',\n    fontSize = 16,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif'\n  } = font;\n  const [gapX, gapY] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  const getMarkStyle = () => {\n    const markStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      markStyle.left = `${positionLeft}px`;\n      markStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      markStyle.top = `${positionTop}px`;\n      markStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n    markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return markStyle;\n  };\n  const containerRef = useRef(null);\n  const watermarkRef = useRef();\n  const {\n    createObserver,\n    destroyObserver,\n    reRendering\n  } = useMutationObserver();\n  const destroyWatermark = () => {\n    if (watermarkRef.current) {\n      watermarkRef.current.remove();\n      watermarkRef.current = undefined;\n    }\n  };\n  const appendWatermark = (base64Url, markWidth) => {\n    var _a;\n    if (containerRef.current && watermarkRef.current) {\n      destroyObserver();\n      watermarkRef.current.setAttribute('style', getStyleStr(Object.assign(Object.assign({}, getMarkStyle()), {\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${(gapX + markWidth) * BaseSize}px`\n      })));\n      (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.current);\n      createObserver(containerRef.current, mutations => {\n        mutations.forEach(mutation => {\n          if (reRendering(mutation, watermarkRef.current)) {\n            destroyWatermark();\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderWatermark();\n          }\n        });\n      });\n    }\n  };\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const widths = contents.map(item => ctx.measureText(item).width);\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(widths)));\n      defaultHeight = Number(fontSize) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n    const ratio = getPixelRatio();\n    const mergedFontSize = Number(fontSize) * ratio;\n    ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${drawHeight}px ${fontFamily}`;\n    ctx.fillStyle = color;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    ctx.translate(drawWidth / 2, 0);\n    const contents = Array.isArray(content) ? content : [content];\n    contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n      ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n    });\n  };\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      if (!watermarkRef.current) {\n        watermarkRef.current = document.createElement('div');\n      }\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const canvasWidth = (gapX + markWidth) * ratio;\n      const canvasHeight = (gapY + markHeight) * ratio;\n      canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n      canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n      const drawX = gapX * ratio / 2;\n      const drawY = gapY * ratio / 2;\n      const drawWidth = markWidth * ratio;\n      const drawHeight = markHeight * ratio;\n      const rotateX = (drawWidth + gapX * ratio) / 2;\n      const rotateY = (drawHeight + gapY * ratio) / 2;\n      /** Alternate drawing parameters */\n      const alternateDrawX = drawX + canvasWidth;\n      const alternateDrawY = drawY + canvasHeight;\n      const alternateRotateX = rotateX + canvasWidth;\n      const alternateRotateY = rotateY + canvasHeight;\n      ctx.save();\n      rotateWatermark(ctx, rotateX, rotateY, rotate);\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n          /** Draw interleaved pictures after rotation */\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        };\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n        /** Fill the interleaved text after rotation */\n        ctx.restore();\n        rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n        fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n        appendWatermark(canvas.toDataURL(), markWidth);\n      }\n    }\n  };\n  useEffect(renderWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, gapX, gapY, offsetLeft, offsetTop]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    className: className,\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, children);\n};\nexport default Watermark;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}