{"ast":null,"code":"import e from \"compute-scroll-into-view\";\nlet t = e => !1 === e ? {\n  block: \"end\",\n  inline: \"nearest\"\n} : (e => e === Object(e) && 0 !== Object.keys(e).length)(e) ? e : {\n  block: \"start\",\n  inline: \"nearest\"\n};\nfunction o(o, l) {\n  let n = o.isConnected || o.ownerDocument.documentElement.contains(o);\n  if ((e => \"object\" == typeof e && \"function\" == typeof e.behavior)(l)) return l.behavior(n ? e(o, l) : []);\n  if (!n) return;\n  let r = t(l),\n    c = e(o, r),\n    i = (\"scrollBehavior\" in document.body.style);\n  c.forEach(e => {\n    let {\n      el: t,\n      top: o,\n      left: l\n    } = e;\n    t.scroll && i ? t.scroll({\n      top: o,\n      left: l,\n      behavior: r.behavior\n    }) : (t.scrollTop = o, t.scrollLeft = l);\n  });\n}\nexport { o as default };","map":{"version":3,"mappings":";AA6BA,IAUIA,IAAcC,MAEA,MAAZA,IACK;EAAEC,OAAO;EAAOC,QAAQ;AAAA,IAZjCF,MAEAA,MAAYG,OAAOH,MAA4C,MAAhCG,OAAOC,KAAKJ,GAASK,QAavBL,KAEpBA,IAIF;EAAEC,OAAO;EAASC,QAAQ;AAAA;AAiBX,WACtBI,GACAN;EAGA,IAAIO,IACFD,EAAOE,eACPF,EAAOG,cAAeC,gBAAiBC,SAASL;EAE9C,IA1CJN,MAEmB,mBAAZA,KAAmD,qBAArBA,EAAQY,UAwCfZ,IACrB,SAAQY,SAASL,IAAmBM,EAAQP,GAAQN,KAAW;EAIxE,KAAKO,GACH;EAIE,QAAiBR,EAAWC;IAC5Bc,IAAUD,EAAQP,GAAQS;IAC1BC,KAAkB,oBAAoBC,SAASC,KAAKC;EAExDL,EAAQM,QAAQC;IAAuB;MAAtBC,IAAEA;MAAIC;MAAAC,MAAKA;IAAAA,IAAWH;IAGjCC,EAAGG,UAAUT,IACfM,EAAGG,OAAO;MAAEF;MAAKC;MAAMZ,UAAUG,EAAeH;IAAAA,MAEhDU,EAAGI,YAAYH,GACfD,EAAGK,aAAaH,EAClB;EAAA,EAEJ;AAAA;AAAA","names":["getOptions","options","block","inline","Object","keys","length","target","isTargetAttached","isConnected","ownerDocument","documentElement","contains","behavior","compute","actions","computeOptions","canSmoothScroll","document","body","style","forEach","_ref","el","top","left","scroll","scrollTop","scrollLeft"],"sources":["C:\\Users\\nimes\\OneDrive\\Desktop\\Project\\Imageupload\\frontend\\node_modules\\scroll-into-view-if-needed\\src\\index.ts"],"sourcesContent":["import compute from 'compute-scroll-into-view'\nimport type {\n  Options as BaseOptions,\n  ScrollAction,\n} from 'compute-scroll-into-view'\n\n/** @public */\nexport type Options<T = unknown> =\n  | StandardBehaviorOptions\n  | CustomBehaviorOptions<T>\n\n/** @public */\nexport interface StandardBehaviorOptions extends BaseOptions {\n  /**\n   * @defaultValue 'auto\n   */\n  behavior?: ScrollBehavior\n}\n\n/** @public */\nexport interface CustomBehaviorOptions<T = unknown> extends BaseOptions {\n  behavior: CustomScrollBehaviorCallback<T>\n}\n\n/** @public */\nexport type CustomScrollBehaviorCallback<T = unknown> = (\n  actions: ScrollAction[]\n) => T\n\nlet isStandardScrollBehavior = (\n  options: any\n): options is StandardBehaviorOptions =>\n  options === Object(options) && Object.keys(options).length !== 0\n\nlet isCustomScrollBehavior = <T = unknown>(\n  options: any\n): options is CustomBehaviorOptions<T> =>\n  typeof options === 'object' ? typeof options.behavior === 'function' : false\n\nlet getOptions = (options: any): StandardBehaviorOptions => {\n  // Handle alignToTop for legacy reasons, to be compatible with the spec\n  if (options === false) {\n    return { block: 'end', inline: 'nearest' }\n  }\n\n  if (isStandardScrollBehavior(options)) {\n    // compute.ts ensures the defaults are block: 'center' and inline: 'nearest', to conform to the spec\n    return options\n  }\n\n  // if options = {}, options = true or options = null, based on w3c web platform test\n  return { block: 'start', inline: 'nearest' }\n}\n\n// Some people might use both \"auto\" and \"ponyfill\" modes in the same file, so we also provide a named export so\n// that imports in userland code (like if they use native smooth scrolling on some browsers, and the ponyfill for everything else)\n// the named export allows this `import {auto as autoScrollIntoView, ponyfill as smoothScrollIntoView} from ...`\n/** @public */\nexport default function scrollIntoView<T>(\n  target: Element,\n  options: CustomBehaviorOptions<T>\n): T\n/** @public */\nexport default function scrollIntoView(\n  target: Element,\n  options?: StandardBehaviorOptions | boolean\n): void\n/** @public */\nexport default function scrollIntoView<T = unknown>(\n  target: Element,\n  options?: StandardBehaviorOptions | CustomBehaviorOptions<T> | boolean\n): T | void {\n  // Browsers treats targets that aren't in the dom as a no-op and so should we\n  let isTargetAttached =\n    target.isConnected ||\n    target.ownerDocument!.documentElement!.contains(target)\n\n  if (isCustomScrollBehavior<T>(options)) {\n    return options.behavior(isTargetAttached ? compute(target, options) : [])\n  }\n\n  // Don't do anything if using a standard behavior on an element that is not in the document\n  if (!isTargetAttached) {\n    return\n  }\n\n  // @TODO see if it's possible to avoid this assignment\n  let computeOptions = getOptions(options)\n  let actions = compute(target, computeOptions)\n  let canSmoothScroll = 'scrollBehavior' in document.body.style\n\n  actions.forEach(({ el, top, left }) => {\n    // browser implements the new Element.prototype.scroll API that supports `behavior`\n    // and guard window.scroll with supportsScrollBehavior\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({ top, left, behavior: computeOptions.behavior })\n    } else {\n      el.scrollTop = top\n      el.scrollLeft = left\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}